#!/usr/bin/env zsh

## env setup

# include zsh_libmisc, load needed library functions
fpath=(/usr/lib/zsh_libmisc/libmisc.zwc $fpath)
autoload query_jobs

# read puzzle input into 2d array, error if file 'input' not found
[ -f input ] || {
  print "Error: \'input\' not found"
  return 1
}
unset dayfour_input
declare -A dayfour_input
input_raw=$(< input)
x_readin=0
y_readin=0
# fetch x length
ex_length=139
# fetch y length
why_length=139
IFS=$'\n'
for y_line in $=input_raw; do
  ((y_readin+=1))
  while true; do
    ((x_readin+=1))
    x_indice=${y_line: :1}
    y_line=${y_line:1}
    [ -z "$x_indice" ] && {
      x_readin=0
      break
    }
    dayfour_input[$x_readin,$y_readin]=$x_indice
  done
done
unset IFS

# initialize worker_id var
worker_id=0

# initialize worker_ids arr
declare -a worker_ids

# remove working dir if exist, and remake
[ -d /tmp/dayfour_working ] && {
  rm -rf /tmp/dayfour_working
}
mkdir /tmp/dayfour_working

# initialize x pointer
ex_pointer=0

# initialize y pointer
why_pointer=0

# initialize result var
result=0

# set default thread count if j is undefined
[ -z "$j" ] && {
  j=$((nproc+1))
}

## helper functions

# query one indice in every direction from current pos.
query_hitbox() {
  # defines array qh_directions as containing all possible directions
  qh_directions=(""$((ex-1))","$why""
                 ""$((ex+1))","$why""
                 ""$ex","$((why-1))""
                 ""$ex","$((why+1))""
                 ""$((ex-1))","$((why-1))""
                 ""$((ex+1))","$((why+1))""
                 ""$((ex-1))","$((why+1))""
                 ""$((ex+1))","$((why-1))""
                )
  # query one indice in every direction, print contents
  for qh_dir in $qh_directions[@]; do
    print $dayfour_input[$qh_dir]
  done
}
alias qh=query_hitbox

tally_adj() {
  # initialize adj @ var
  tallied=0
  # fetch adjacent chars via query_hitbox
  to_tally=$(ex=$ex why=$why qh)
  # set ifs to newline and iterate over each
  IFS=$'\n'
  for tally_ho in $=to_tally; do
    # if line contains @, add it to adjacent @ tally
    [[ "$tally_ho" = *'@'* ]] && {
      tallied=$((tallied+1))
    }
  done
  unset IFS
  # since this is small int (< 8), we can use return for result
  return $tallied
}

create_worker() {
  # ensure current indice is @
  indice_contains=$dayfour_input[$ex,$why]
  [[ "$indice_contains" = *'@'* ]] && {
    # fetch total @ from tally_adj
    ex=$ex why=$why tally_adj
    ta_res=$?
    # if tally smaller than 4, print 1 to worker result
    ((ta_res<4)) && {
      print '1' > /tmp/dayfour_working/$worker_id
    # else print 0 to worker results
    } || {
      print '0' > /tmp/dayfour_working/$worker_id
    }
  # if indice not @, skip above and print 0 to worker result
  } || {
    print '0' > /tmp/dayfour_working/$worker_id
  }
}

## main
while true; do
  # increase x pointer
  ((ex_pointer+=1))
  # if x pointer exceeds x length
  ((ex_pointer>ex_length)) && {
    # set x pointer to 1, and increase y counter by 1
    ((why_pointer+=1))
    ex_pointer=1
  }
  # if y pointer exceeds y length, break loop
  ((why_pointer>why_length)) && {
    break
  }
  # increase worker id num, add new id to id arr
  ((worker_id+=1))
  worker_ids+=("$worker_id")
  # if active jobs >= j, wait until < j
  [ "$(query_jobs)" -ge "$j" ] && {
    until [ "$(query_jobs)" -lt "$j" ]; do
      sleep 1
    done
  }
  # start worker for current x y pointers
  ex=$ex_pointer why=$why_pointer create_worker &
done

# wait for workers to finish
for chk_id in $worker_ids[@]; do
  until [ -f /tmp/dayfour_working/$chk_id ]; do
    sleep 1
  done
done

# tally up result
for final_tally in $worker_ids[@]; do
  le_tallie=$(< /tmp/dayfour_working/$final_tally)
  [ $le_tallie = 1 ] && {
    ((result+=1))
  }
done

# print result
print $result

#cleanup
rm -rf /tmp/dayfour_working
