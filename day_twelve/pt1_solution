#!/usr/bin/env zsh

## env setup

# check for presence of puzzle input, error out if not found
[ -f input ] || {
  print "Error: could not find \'input\'"
  return 1
}

# alias integer to int for brevity
alias int="integer"

# array declarations
declare -A floor_spaces shapes areas
declare -a floor_ids presents current_shape_lines

# variable declarations
int sepflag floor_id

## helper functions

# rotates coord string 90deg (clockwise)
rotate_coords() {
  rc_input_coords="$1"
  rc_new_coords=()
  for coord in $=rc_input_coords; do
    rc_x=${coord%,*}
    rc_y=${coord#*,}
    rc_new_coords+=("$((-rc_y)),$rc_x")
  done
  print "${rc_new_coords[*]}"
}

# normalize negative coords (generated from rotation) to 0,0
normalize_coords() {
  nc_input_coords="$1"
  int nc_min_x=999 nc_min_y=999
  # find minimum
  for coord in $=nc_input_coords; do
    nc_x=${coord%,*}
    nc_y=${coord#*,}
    ((nc_x<nc_min_x)) && nc_min_x=$nc_x
    ((nc_y<nc_min_y)) && nc_min_y=$nc_y
  done
  # shift remaining
  nc_out=()
  for coord in $=nc_input_coords; do
    nc_x=${coord%,*}
    nc_y=${coord#*,}
    nc_out+=("$((nc_x-nc_min_x)),$((nc_y-nc_min_y))")
  done
  print "${nc_out[*]}"
}

# checks if shape fits in a given floor space
check_fit() {
  # fetch input
  fid="$1"
  int start_x="$2"
  int start_y="$3"
  shape_coords="$4"
  int target_x
  int target_y
  for coord in $=shape_coords; do
    # split coord into idx and idy
    idx=${coord%,*}
    idy=${coord#*,}
    ((target_x=start_x+idx))
    ((target_y=start_y+idy))
    # check floor at this spot
    floor_space="${floor_spaces[$fid,$target_x,$target_y]}"
    # fail if oob
    [[ -z "$floor_space" ]] && {
      return 1
    }
    # fail if space is full
    [[ "$floor_space" != "." ]] && {
      return 1
    }
  done
  # if loop didn't return 1, return 0 (space fits)
  return 0
}

# convert buffered lines into coords
process_shape_buffer() {
  psb_id="$1"
  # if no lines, skip
  ((${#current_shape_lines}==0)) && return 0
  # arrays, vars
  psb_coords=()
  int y=0
  int block_count=0
  # iterate over current_shape_lines
  for row in $current_shape_lines; do
    # split string (row) into chars
    psb_chars=(${(s::)row})
    int x=0
    for char in $psb_chars; do
      [[ "$char" = '#' ]] && {
        # store x,y coords
        psb_coords+=("$x,$y")
        ((block_count++))
      }
      ((x++))
    done
    ((y++))
  done

  # store results
  shapes[$psb_id]="${psb_coords[*]}"
  areas[$psb_id]=$block_count

  # clear buffer
  current_shape_lines=()
}

# prints grid corresponding to x and y val
print_grid() {
  x_val="$1"
  y_val="$2"
  y_count=0
  while true; do
    ((y_count++))
    ((y_count>y_val)) && break
    x_count=0
    while true; do
      ((x_count++))
      ((x_count>x_val)) && break
      print -n '.'
    done
    print
  done
}

## parsing steps

# 1 - read + separate puzzle sections
while read -r -u0 line; do
  # if line contains x, we've entered floor space
  [[ "$line" = *"x"* ]] && {
    ((sepflag=1))
  }
  # if sepflag is 0, we haven't encountered a floor line yet
  ((sepflag==0)) && {
    # if line contains ":", then line is an index definition
    [[ "$line" = *":"* ]] && {
      [ -n "$index" ] && process_shape_buffer "$index"
      index=${line%:}
    # else, is a box shape definition - store under "current_shape_lines"
    } || {
      ((sepflag==0)) && {
        current_shape_lines+=("$line")
      }
    }
  # else, these are floor lines, and we handle accordingly
  } || {
    ((floor_id++))
    floor_ids+=("$floor_id")
    gridsize=${line%:*}
    present=${line#*:}
    x=${gridsize%x*}
    y=${gridsize#*x}
    grid=$(print_grid "$x" "$y")
    y_count=0
    IFS=$'\n'; for grid_y in $=grid; do
      ((y_count++))
      x_count=0
      while true; do
        working_indice=${grid_y: :1}
        grid_y=${grid_y:1}
        [ -z "$working_indice" ] && break
        ((x_count++))
        floor_spaces[$floor_id,$x_count,$y_count]=$working_indice
      done
    done; unset IFS
    presents[$floor_id]="$present"
  }
done < <(<input)

[ -n "$index" ] && process_shape_buffer "$index"

# we now have several logical structures made from input with which to query.
# this executes very, very quickly

# uncomment below for verification of above functionality
#print $shapes[0]
