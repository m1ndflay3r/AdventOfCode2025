#!/usr/bin/env zsh

## env setup

# check for presence of puzzle input, error out if not found
[ -f input ] || {
  print "Error: could not find \'input\'"
  return 1
}

# alias integer to int for brevity
alias int="integer"

# array declarations
declare -A floor_spaces shapes areas floor_dims variation_cache
declare -a floor_ids presents current_shape_lines

# variable declarations
int sepflag floor_id

## helper functions

# sort presents from largest to smallest (crucial for speed)
sort_presents() {
  sp_list=($=1)
  # bubble sort (more than fast enough for the data size)
  int sp_working=${#list}
  for ((a=1; a<sp_working; a++)); do
    for ((b=1; b<=sp_working-a; b++)); do
      sp_id1=${list[$b]}
      sp_id2=${list[$b+1]}
      ((areas[$sp_id1] < areas[$sp_id2])) && {
        # swap
        list[$b]=$sp_id2
        list[$b+1]=$sp_id1
      }
    done
  done
  print "${list[*]}"
}

# pre-computation for rotation/flips
precompute_variations() {
  prv_shape_id="$1"
  [[ -n "${variation_cache[$shape_id,0]}" ]] && return 0
  prv_current_coords="${shapes[$shape_id]}"

  # first 4 rotations
  for c in {0..3}; do
    prv_current_coords=$(rotate_coords "$prv_current_coords")
    prv_norm=$(normalize_coords "$prv_current_coords")
    variation_cache[$prv_shape_id,$c]="$prv_norm"
  done

  # flip and 4 rotations
  prv_flipped=''
  for d in $=prv_current_coords; do
    prv_fx=${d%,*}
    prv_fy=${d#*,}
    prv_flipped+="$((-prv_fx)),$prv_fy"
  done
  prv_current_coords="$prv_flipped"

  for e in {4..7}; do
    prv_current_coords=$(rotate_coords "$prv_current_coords")
    prv_norm=$(normalize_coords "$prv_current_coords")
    variation_cache[$prv_shape_id,$e]="$prv_norm"
  done
}

# rotates coord string 90deg (clockwise)
rotate_coords() {
  rc_input_coords="$1"
  rc_new_coords=()
  for coord in $=rc_input_coords; do
    rc_x=${coord%,*}
    rc_y=${coord#*,}
    rc_new_coords+=("$((-rc_y)),$rc_x")
  done
  print "${rc_new_coords[*]}"
}

# normalize negative coords (generated from rotation) to 0,0
normalize_coords() {
  nc_input_coords="$1"
  int nc_min_x=999 nc_min_y=999
  # find minimum
  for coord in $=nc_input_coords; do
    nc_x=${coord%,*}
    nc_y=${coord#*,}
    ((nc_x<nc_min_x)) && nc_min_x=$nc_x
    ((nc_y<nc_min_y)) && nc_min_y=$nc_y
  done
  # shift remaining
  nc_out=()
  for coord in $=nc_input_coords; do
    nc_x=${coord%,*}
    nc_y=${coord#*,}
    nc_out+=("$((nc_x-nc_min_x)),$((nc_y-nc_min_y))")
  done
  print "${nc_out[*]}"
}

# checks if shape fits in a given floor space
check_fit() {
  # fetch input
  fid="$1"
  int start_x="$2"
  int start_y="$3"
  shape_coords="$4"
  int target_x
  int target_y
  for coord in $=shape_coords; do
    # split coord into idx and idy
    idx=${coord%,*}
    idy=${coord#*,}
    ((target_x=start_x+idx))
    ((target_y=start_y+idy))
    # check floor at this spot
    floor_space="${floor_spaces[$fid,$target_x,$target_y]}"
    # fail if oob
    [[ -z "$floor_space" ]] && {
      return 1
    }
    # fail if space is full
    [[ "$floor_space" != "." ]] && {
      return 1
    }
  done
  # if loop didn't return 1, return 0 (space fits)
  return 0
}

# convert buffered lines into coords
process_shape_buffer() {
  psb_id="$1"
  # if no lines, skip
  ((${#current_shape_lines}==0)) && return 0
  # arrays, vars
  psb_coords=()
  int y=0
  int block_count=0
  # iterate over current_shape_lines
  for row in $current_shape_lines; do
    # split string (row) into chars
    psb_chars=(${(s::)row})
    int x=0
    for char in $psb_chars; do
      [[ "$char" = '#' ]] && {
        # store x,y coords
        psb_coords+=("$x,$y")
        ((block_count++))
      }
      ((x++))
    done
    ((y++))
  done

  # store results
  shapes[$psb_id]="${psb_coords[*]}"
  areas[$psb_id]=$block_count

  # clear buffer
  current_shape_lines=()
}

# prints grid corresponding to x and y val
print_grid() {
  x_val="$1"
  y_val="$2"
  y_count=0
  while true; do
    ((y_count++))
    ((y_count>y_val)) && break
    x_count=0
    while true; do
      ((x_count++))
      ((x_count>x_val)) && break
      print -n '.'
    done
    print
  done
}

# grid modifier
modify_grid() {
  mg_fid="$1"
  mg_start_x="$2"
  mg_start_y="$3"
  mg_shape_coords="$4"
  mg_char="$5"

  int target_x target_y
  for coord in $=mg_shape_coords; do
    mg_idx=${coord%,*}
    mg_idy=${coord#*,}
    ((target_x=mg_start_x+mg_idx))
    ((target_y=mg_start_y+mg_idy))
    floor_spaces[$mg_fid,$target_x,$target_y]="$mg_char"
  done
}

solve_floor() {
}

## parsing steps

# 1 - read + separate puzzle sections
while read -r -u0 line; do
  # if line contains x, we've entered floor space
  [[ "$line" = *"x"* ]] && {
    ((sepflag=1))
  }
  # if sepflag is 0, we haven't encountered a floor line yet
  ((sepflag==0)) && {
    # if line contains ":", then line is an index definition
    [[ "$line" = *":"* ]] && {
      [ -n "$index" ] && process_shape_buffer "$index"
      index=${line%:}
    # else, is a box shape definition - store under "current_shape_lines"
    } || {
      ((sepflag==0)) && {
        current_shape_lines+=("$line")
      }
    }
  # else, these are floor lines, and we handle accordingly
  } || {
    ((floor_id++))
    floor_ids+=("$floor_id")
    gridsize=${line%:*}
    present=${line#*:}
    x=${gridsize%x*}
    y=${gridsize#*x}
    floor_dims[$floor_id]="$x $y"
    grid=$(print_grid "$x" "$y")
    y_count=0
    IFS=$'\n'; for grid_y in $=grid; do
      ((y_count++))
      x_count=0
      while true; do
        working_indice=${grid_y: :1}
        grid_y=${grid_y:1}
        [ -z "$working_indice" ] && break
        ((x_count++))
        floor_spaces[$floor_id,$x_count,$y_count]=$working_indice
      done
    done; unset IFS
    presents[$floor_id]="$present"
  }
done < <(<input)
# process last shape in buffer
[ -n "$index" ] && process_shape_buffer "$index"
