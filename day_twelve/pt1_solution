#!/usr/bin/env zsh

## env setup

# check for presence of puzzle input, error out if not found
[ -f input ] || {
  print "Error: could not find \'input\'"
  return 1
}

# alias integer to int for brevity
alias int="integer"

# array declarations
declare -A floor_spaces shapes areas
declare -a floor_ids presents current_shape_lines

# variable declarations
int sepflag floor_id

## helper functions

# prints matrix
check_fit() {
  fid="$1"
  int start_x="$2"
  int start_y="$3"
  shape_coords="$4"
  int target_x
  int target_y
  for coord in $=shape_coords; do
    # split coord into idx and idy
    idx=${coord%,*}
    idy=${coord#*,}
    ((target_x=start_x+idx))
    ((target_y=start_y+idy))
    # check floor at this spot
    floor_space="$floor_spaces[$fid,$target_x,$target_y]"
    # fail if oob
    [[ -z "$floor_space" ]] && {
      return 1
    }
    # fail if space is full
    [[ "$floor_space" != "." ]] && {
      return 1
    }
  done
  # if loop didn't return 1, return 0 (space fits)
  return 0
}

process_shape_buffer() {
  psb_id="$1"
  # if no lines, skip
  ((${#current_shape_lines}==0)) && return 0
  # arrays, vars
  psb_coords=()
  int y=0
  int block_count=0
  # iterate over current_shape_lines
  for row in $current_shape_lines; do
    # split string (row) into chars
    psb_chars=(${(s::)row})
    int x=0
    for char in $psb_chars; do
      [[ "$char" = '#' ]] && {
        # store x,y coords
        psb_coords+=("$x,$y")
        ((block_count++))
      }
      ((x++))
    done
    ((y++))
  done
  shapes[$psb_id]="${psb_coords[*]}"
  areas[$psb_id]=$block_count

  current_shape_lines=()
}

# prints grid corresponding to x and y val
print_grid() {
  x_val="$1"
  y_val="$2"
  y_count=0
  while true; do
    ((y_count++))
    ((y_count>y_val)) && break
    x_count=0
    while true; do
      ((x_count++))
      ((x_count>x_val)) && break
      print -n '.'
    done
    print
  done
}

## parsing steps

# 1 - read + separate puzzle sections
while read -r -u0 line; do
  # if line contains x, we've entered floor space
  [[ "$line" = *"x"* ]] && {
    ((sepflag=1))
  }
  # if sepflag is 0, we haven't encountered a floor line yet
  ((sepflag=0)) && {
    # if line contains ":", then line is an index definition
    [[ "$line" = *":"* ]] && {
      [ -n "$index" ] && process_shape_buffer "$index"
      index=${line: :1}
    # else, is a box shape definition - store under "current_shape_lines"
    } || {
      ((sepflag==0)) && {
        current_shape_lines+=("$line")
      }
    }
  # else, these are floor lines, and we handle accordingly
  } || {
    ((floor_id++))
    floor_ids+=("$floor_id")
    gridsize=${line%:*}
    present=${line#*:}
    x=${gridsize%x*}
    y=${gridsize#*x}
    grid=$(print_grid "$x" "$y")
    y_count=0
    IFS=$'\n'; for grid_y in $=grid; do
      ((y_count++))
      x_count=0
      while true; do
        working_indice=${grid_y: :1}
        grid_y=${grid_y:1}
        [ -z "$working_indice" ] && break
        ((x_count++))
        floor_spaces[$floor_id,$x_count,$y_count]=$working_indice
      done
    done; unset IFS
    presents[$floor_id]="$present"
  }
done < <(<input)

# we now have several logical structures made from input with which to query.
# this executes very, very quickly
