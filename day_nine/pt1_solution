#!/usr/bin/env zsh

## env setup

# fetch input, err if not found
daynine_input=$(<input) || {
  print "Error: could not find \'input\'"
  return 1
}

# swap hash for another char (ease of parsing)
daynine_input=${daynine_input//'#'/'K'}

# load zsh/mathfunc module for sqrt
zmodload zsh/mathfunc

# associative array for grid storage
declare -A daynine_grid

# associative array for distance storage
declare -A distances

# associative array for key of furthest corner
declare -A far_corners

## parsing steps

# move input into associative array
y_count=0
IFS=$'\n'
for line in $=daynine_input; do
  x_count=0
  ((y_count++))
  while true; do
    working=${line: :1}
    line=${line:1}
    [ -z "$working" ] && {
      break
    }
    ((x_count++))
    daynine_grid[$x_count,$y_count]=$working
  done
done
unset IFS

## helper functions

# search grid by char
search_grid() {
  [ -z "$search_char" ] && {
    search_char="$1"
  }
  dg_keys=$daynine_grid[(I)*,*]
  IFS=$' '
  for key in ${(@on)=dg_keys}; do
    [ "$daynine_grid[$key]" = "$search_char" ] && {
      print $key
    }
  done
  unset IFS
}

# extract y coord only from key
print_y() {
  [ -z "$key" ] && {
    key="$1"
  }
  firstloop=0
  IFS=$','
  for coord in $=key; do
    [ "$firstloop" = 1 ] && {
      print $coord
    }
    firstloop=1
  done
  unset IFS
}

# extract x coord only from key
print_x() {
  [ -z "$key" ] && {
    key="$1"
  }
  firstloop=0
  IFS=$','
  for coord in $=key; do
    [ "$firstloop" = 0 ] && {
      print $coord
    }
    firstloop=1
  done
  unset IFS
}

# calculate distance between any two corners
gib_dist() {
  [ -z "$key1" ] && {
    key1="$1"
  }
  [ -z "$key2" ] && {
    key2="$2"
  }
  y1=$(print_y "$key1")
  x1=$(print_x "$key1")
  y2=$(print_y "$key2")
  x2=$(print_x "$key2")
  integer dist
  dist=$((sqrt(((y2-y1)*(y2-y1))+((x2-x1)*(x2-x1)))))
  print $dist
}

# calculate corner furthest from a given key
gib_big_dist() {
  # fetch key to check
  [ -z "$key" ] && {
    key=$1
  }
  # acquire all possible corners
  corners=$(search_grid 'K')
  # initialize furthest and currentfurthest
  furthest=0
  currentfurthest=''
  # iterate over corners by newline
  IFS=$'\n'
  for corner in $=corners; do
    # skip if $key and $corner are the same
    [ "$key" != "$corner" ] && {
      # get distance between $corner and $key
      distance=$(key1=$key key2=$corner gib_dist)
      # if distance is bigger than current furthest, then is new furthest
      ((distance>furthest)) && {
        furthest="$distance"
        # currentfurthest records key of furthest corner thus far
        currentfurthest="$corner"
      }
    }
  done
  unset IFS
  # set associative arrays according to results for easy querying
  distances[$key]="$furthest"
  far_corners[$key]="$currentfurthest"
}

## main

# distance calculations

# acquire position of all possible corners
all_corners=$(search_grid 'K')
furthest='0'
furthest_corner=''
# iterate over corners line by line
IFS=$'\n'
for chk_corner in $=all_corners; do
  # run gib_big_dist on every corner to acquire needed data
  gib_big_dist "$chk_corner"
  # if distance is greater than current furthest, it becomes new furthest
  ((distances[chk_corner]>furthest)) && {
    furthest="$distances[$chk_corner]"
    # we only need to record one corner since we can find the other with $far_corners[$furthest_corner]
    furthest_corner="$chk_corner"
  }
done
unset IFS

print "Furthest distance between two corners: "$furthest""
print "Corner 1: "$furthest_corner""
print "Corner 2: "$far_corners[$furthest_corner]""
