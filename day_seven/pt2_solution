#!/usr/bin/env zsh

## env setup

# read input into variable, error if not found
dayseven_input=$(<input) || {
  print "Error: \'input\' not found"
  return 1
}

# declare associative array
declare -A dayseven_grid

# declare counts array
declare -A counts

# parse input line by line, read into associative array
why_count=0
IFS=$'\n'
for input_line in $=dayseven_input; do
  ((why_count++))
  eks_count=0
  while true; do
    working_indice=${input_line: :1}
    input_line=${input_line:1}
    [ -z "$working_indice" ] && {
      break
    }
    ((eks_count++))
    dayseven_grid[$why_count,$eks_count]=$working_indice
  done
done
unset IFS

# initialize result var
result=0

## helper functions

# search grid by char
search_grid() {
  dg_keys=$dayseven_grid[(I)*,*]
  IFS=$' '
  for key in ${(@on)=dg_keys}; do
    [ "$dayseven_grid[$key]" = "$search_char" ] && {
      print $key
    }
  done
  unset IFS
}

## main

# find start pos
begin_key=$(search_char='S' search_grid)
# initialize timeline count
counts[$begin_key]=1

# iterate through rows (gravity) from top to bottom
for ((why=1; why<=why_count; why++)); do
  # fetch active positions in current row
  row_keys=(${(k)counts[(I)${why},*]})
  for key in $row_keys; do
    current_count=$counts[$key]
    # fetch current x coord
    eks=${key#*,}
    # calculate coordinates for row below
    next_why=$((why+1))
    # check the character directly below current position
    char_below=$dayseven_grid[$next_why,$eks]
    [[ "$char_below" = "." || "$char_below" = "S" ]] && {
      # pass count straight down
      ((counts[$next_why,$eks]+=current_count))
    } || {
      [[ "$char_below" = "^" ]] && {
        # timeline split - add count to left and right on next row
        ((counts[$next_why,$((eks-1))]+=current_count))
        ((counts[$next_why,$((eks+1))]+=current_count))
      }
    }
  done
done

# fetch keys > grid bottom
final_why=$((why_count+1))
final_keys=(${(k)counts[(I)${final_why},*]})

# if stop on last row, change final_why to $why_count
[ ${#final_keys} -eq 0 ] && {
  final_why=$why_count
  final_keys=(${(k)counts[(I)${final_why},*]})
}

for key in $final_keys; do
  ((result+=counts[$key]))
done

# print result
print $result
