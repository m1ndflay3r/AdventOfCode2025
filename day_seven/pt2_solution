#!/usr/bin/env zsh

## env setup

# read input into variable, error if not found
dayseven_input=$(<input) || {
  print "Error: \'input\' not found"
  return 1
}

# declare associative array
declare -A dayseven_grid

# parse input line by line, read into associative array
why_count=0
IFS=$'\n'
for input_line in $=dayseven_input; do
  ((why_count++))
  eks_count=0
  while true; do
    working_indice=${input_line: :1}
    input_line=${input_line:1}
    [ -z "$working_indice" ] && {
      break
    }
    ((eks_count++))
    dayseven_grid[$why_count,$eks_count]=$working_indice
  done
done
unset IFS

# initialize result var
result=0

## helper functions

# print entire contents of grid
print_grid() {
  # grab dayseven_grid keys
  dg_keys=$dayseven_grid[(I)*,*]
  first_loop=0
  IFS=$' '
  for key in ${(@on)=dg_keys}; do
    [[ "$key" = *",1" ]] && [ "$first_loop" = 1 ] && {
      print
    }
    print -n $dayseven_grid[$key]
    first_loop=1
  done
  unset IFS
}

# search grid by char
search_grid() {
  dg_keys=$dayseven_grid[(I)*,*]
  IFS=$' '
  for key in ${(@on)=dg_keys}; do
    [ "$dayseven_grid[$key]" = "$search_char" ] && {
      print $key
    }
  done
  unset IFS
}

# modify one part of a key, either x or y
modif_key() {
  ret_x=''
  ret_y=''
  firstloop=0
  IFS=$','
  for coord in $=key; do
    [ "$firstloop" = 0 ] && {
      [ "$Y" = 1 ] && {
        ret_y="$y"
      } || {
        ret_y="$coord"
      }
    }
    [ "$firstloop" = 1 ] && {
      [ "$X" = 1 ] && {
        ret_x="$x"
      } || {
        ret_x="$coord"
      }
    }
    firstloop=1
  done
  unset IFS
  print ""$ret_y","$ret_x""
}

# extract x coord only from key
print_x() {
  firstloop=0
  IFS=$','
  for coord in $=key; do
    [ "$firstloop" = 1 ] && {
      print $coord
    }
    firstloop=1
  done
  unset IFS
}

# extract y coord only from key
print_y() {
  firstloop=0
  IFS=$','
  for coord in $=key; do
    [ "$firstloop" = 0 ] && {
      print $coord
    }
    firstloop=1
  done
  unset IFS
}

chonky_adder() {
  local a=$1 b=$2 sum="" carry=0
  local i j digit_a digit_b temp_sum
  # loop from end of strings to beginning
  for (( i=${#a}, j=${#b}; i>0 || j>0 || carry>0; i--, j-- )); do
    # get digit or 0 if index exhausted
    digit_a=${${a[i]}:-0}
    digit_b=${${b[j]}:-0}
    # add digits plus carry
    (( temp_sum = digit_a + digit_b + carry ))
    # update carry and current digit
    (( carry = temp_sum / 10 ))
    sum="$(( temp_sum % 10 ))$sum"
  done
  print $sum
}

## main

# fetch start coords
begin_key=$(search_char='S' search_grid)
begin_eks=$(key=$begin_key print_x)
begin_why=$(key=$begin_key print_y)

# initialize beam array
declare -A le_beam
le_beam[$begin_eks]=1

# propagation loop
for ((why=begin_why; why<=why_count; why++)); do
  unset le_nu_beam
  declare -A le_nu_beam
  # iterate over active columns in curr. row
  for eks in ${(k)le_beam}; do
    count=$le_beam[$eks]
    # fetch current indice
    indice=$dayseven_grid[$why,$eks]
    # if indice is splitter
    [ "$indice" = '^' ] && {
      target=$((eks-1))
      le_nu_beam[$target]=$(chonky_adder ${le_nu_beam[$target]} $count)
      target=$((eks+1))
      le_nu_beam[$target]=$(chonky_adder ${le_nu_beam[$target]} $count)
    # if indice not splitter
    } || {
      le_nu_beam[$eks]=$(chonky_adder ${le_nu_beam[$eks]} $count)
    }
  done
  # replace beam array contents with next beam array contents
  unset le_beam
  declare -A le_beam
  for key in ${(k)le_nu_beam}; do
    le_beam[$key]=$le_nu_beam[$key]
  done
done

# tally results
for le_tallie in ${(@v)le_beam}; do
  result=$(chonky_adder $result $le_tallie)
done

# print results
print $result
