#!/usr/bin/env zsh

## env setup

# include zsh_libmisc, and load needed library functions
fpath=(/usr/lib/zsh_libmisc/libmisc.zwc $fpath)
autoload query_jobs
autoload getstrln
autoload isevennum

# delete tmpdir if exist, and create tmpdir
[ -d /tmp/daytwo_working ] && {
  rm -rf /tmp/daytwo_working
}
mkdir /tmp/daytwo_working

# initialize worker id arr
unset worker_ids
declare -a worker_ids

# read puzzle input
daytwo_input=$(< input) || {
  print "Error: could not find puzzle input"
}

# initialize worker id var
worker_id=0

# initialize result variable
result=0

# thread count - defaults to total threads + 1 if not otherwise specified
# j is used for familiarity
[ -z "$j" ] && {
  j=$(($(nproc)+1))
}

## helper functions

# create worker function - expects a number range to work on.
# uses variable num_range for input
create_worker() {
  # initialize range start + range fin variables
  range_start=''
  range_fin=''
  # initialize output file
  ! [ -f /tmp/daytwo_working/"$worker_id" ] && {
    touch /tmp/daytwo_working/"$worker_id"
  }
  # separate range_start from range_fin using dash for field separation
  IFS=$'-'
  for sep_range in $=num_range; do
    [ -z "$range_start" ] && {
      range_start="$sep_range"
    } || {
      range_fin="$sep_range"
    }
  done
  unset IFS
  # check range for invalid IDs and add to invalid ID array if found
  while true; do
    # discard num if is odd string length since invalid IDs will always be even
    isevennum $(getstrln "$range_start") && {
      # determine length of string and divide by 2
      half_str_ln=$(($(getstrln "$range_start")/2))
      # bisect current number
      str_part_one=${range_start: :$half_str_ln}
      str_part_two=${range_start:$half_str_ln}
      # compare halves - if same, ID is invalid and must be added to invalid ID array
      [ "$str_part_one" = "$str_part_two" ] && {
        print "$range_start" >> /tmp/daytwo_working/"$worker_id"
      }
    }
    #increase range_start to check next num
    range_start=$((range_start+1))
    #break loop if range_start now exceeds range_fin
    [ "$range_start" -gt "$range_fin" ] && {
      break
    }
  done
  touch /tmp/daytwo_working/"$worker_id".comp
}

## main

#iterate over each number range, using comma for field separation
IFS=$','
for num_range in $=daytwo_input; do
  # query current jobs. If is greater or equal to thread count, wait until its less than.
  [ "$(query_jobs)" -ge "$j" ] && {
    until [ "$(query_jobs)" -lt "$j" ]; do
      sleep 1
    done
  }
  # create worker process from number range, fork to background
  worker_id=$((worker_id+1))
  worker_ids+=("$worker_id")
  num_range="$num_range" worker_id="$worker_id" create_worker &
done
unset IFS

# wait for workers to finish
for chk_id_comp in $worker_ids[@]; do
  until [ -f /tmp/daytwo_working/"$chk_id_comp".comp ]; do
    sleep 1
  done
done

# count up results
for tally_workers in $worker_ids[@]; do
  do_tally=$(< /tmp/daytwo_working/"$tally_workers")
  IFS=$'\n'
  for le_increase in $=do_tally; do
    result=$((result+le_increase))
  done
  unset IFS
done

# print results
print $result

# cleanup
rm -rf /tmp/daytwo_working
