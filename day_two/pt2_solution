#!/usr/bin/env zsh

## env setup

# delete tmpdir if exist, and create tmpdir
[ -d /tmp/daytwo_working ] && {
  rm -rf /tmp/daytwo_working
}
mkdir /tmp/daytwo_working

# initialize worker id arr
unset worker_ids
declare -a worker_ids

# read puzzle input
daytwo_input=$(< input) || {
  print "Error: could not find puzzle input"
}

# initialize worker id var
worker_id=0

# initialize result variable
result=0

# thread count - defaults to total threads + 1 if not otherwise specified
# j is used for familiarity
[ -z "$j" ] && {
  j=$(($(nproc)+1))
}

## helper functions

# query current jobs count for parallel process management
query_jobs() {
  local job_counter=0
  while IFS=$'\n' read -r -u0 active_jobs; do
    job_counter=$((job_counter+1))
  done < <(jobs)
}

# create worker function - expects a number range to work on.
# uses variable num_range for input
create_worker() {
  # initialize range start + range fin variables
  range_start=''
  range_fin=''
  # initialize output file
  ! [ -f /tmp/daytwo_working/"$worker_id" ] && {
    touch /tmp/daytwo_working/"$worker_id"
  }
  # separate range_start from range_fin using dash for field separation
  IFS=$'-'
  for sep_range in $=num_range; do
    [ -z "$range_start" ] && {
      range_start="$sep_range"
    } || {
      range_fin="$sep_range"
    }
  done
  unset IFS
  # check range for invalid IDs
  while true; do
    # double working string
    doubled="${range_start}${range_start}"
    # trim first and last characters
    trimmed="${doubled:1:-1}"
    # check if range_start exists the doubled + trimmed string
    [[ "$trimmed" = *"$range_start"* ]] && {
        print "$range_start" >> /tmp/daytwo_working/"$worker_id"
    }
    # increase range_start to check next num
    range_start=$((range_start+1))
    # break loop if range_start now exceeds range_fin
    [ "$range_start" -gt "$range_fin" ] && {
      break
    }
  done
  touch /tmp/daytwo_working/"$worker_id".comp
}


## main

#iterate over each number range, using comma for field separation
IFS=$','
for num_range in $=daytwo_input; do
  # query current jobs. If is greater or equal to thread count, wait until its less than.
  [ "$(query_jobs)" -ge "$j" ] && {
    until [ "$(query_jobs)" -lt "$j" ]; do
      sleep 1
    done
  }
  # create worker process from number range, fork to background
  worker_id=$((worker_id+1))
  worker_ids+=("$worker_id")
  num_range="$num_range" worker_id="$worker_id" create_worker &
done
unset IFS

# wait for workers to finish
for chk_id_comp in $worker_ids[@]; do
  until [ -f /tmp/daytwo_working/"$chk_id_comp".comp ]; do
    sleep 1
  done
done

# count up results
for tally_workers in $worker_ids[@]; do
  do_tally=$(< /tmp/daytwo_working/"$tally_workers")
  IFS=$'\n'
  for le_increase in $=do_tally; do
    result=$((result+le_increase))
  done
  unset IFS
done

# print results
print $result

# cleanup
rm -rf /tmp/daytwo_working
