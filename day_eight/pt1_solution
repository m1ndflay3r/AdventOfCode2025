#!/usr/bin/env zsh

## env setup

# read puzzle input into variable, err if not found
dayeight_input=$(<input) || {
  print "Error: unable to find \'input\'"
  return 1
}

# alias for brevity
alias int="integer"

# declare arrays
declare -a parent size distances final_tally x y z

# initialize connections
int connections=0

## helper functions

# extract x coord only from key
print_x() {
  firstloop=0
  IFS=$','
  for coord in $=key; do
    out=$coord
  done
  unset IFS
  print $out
}

# extract y coord only from key
print_y() {
  firstloop=0
  IFS=$','
  for coord in $=key; do
    [ "$firstloop" = 1 ] && {
      print $coord
      break
    }
    firstloop=1
  done
  unset IFS
}

# extract z coord only from key
print_z() {
  firstloop=0
  IFS=$','
  for coord in $=key; do
    print $coord
    break
  done
  unset IFS
}

# distance calculator
get_dist() {
  int key1=$1
  int key2=$2
  ret=$3
  int kx=$((x[key1]-x[key2]))
  int ky=$((y[key1]-y[key2]))
  int kz=$((z[key1]-z[key2]))
  int dist=$(((kx*kx)+(ky*ky)+(kz*kz)))
  eval "$ret=$dist"
}

find_root() {
  int working=$i
  ret=$2
  int root=$working
  while ((parent[root] != root)); do
    root=$parent[root]
  done
  int curr=$working
  while ((curr != root)); do
    int next=$parent[curr]
    parent[curr]=$root
    curr=$next
  done
  eval "$ret=$root"
}

## parse steps

junctions=0

IFS=$'\n'
for key in $=dayeight_input; do
  ((junctions++))
  x[$junctions]=$(print_x)
  y[$junctions]=$(print_y)
  z[$junctions]=$(print_z)
done
unset IFS

print "parsed "$junctions" junctions"

## main

box_a=0
while true; do
  ((box_a++))
  ((box_a>junctions)) && {
    break
  }
  box_b=$((box_a+1))
  while true; do
    ((box_b>junctions)) && {
      break
    }
    int le_value
    get_dist $box_a $box_b le_value
    distances+="$le_value:$box_a:$box_b"
    ((box_b++))
  done
done

print "Sorting..."
distances=("${(@on)distances}")

print "top 5 closest pairs"
print -l ${distances[1,5]}

# we know our code works up to here

count=0
while true; do
  ((count++))
  ((count>junctions)) && {
    break
  }
  parent[$count]=$count
  size[$count]=1
done

for edge in "${distances[1,1000]}"; do
  le_dist=''
  you=''
  vee=''
  IFS=':' read -r le_dist you vee <<< "$edge"
  int root_you root_vee
  find_root $you root_you
  find_root $vee root_vee
  ((root_you != root_v)) && {
    ((size[root_you]<size[root_vee])) && {
      parent[root_you]=$root_vee
      ((size[root_vee]+=size[root_you]))
    } || {
      parent[root_vee]=$root_you
      ((size[root_you+=size[root_vee]))
    }
    ((connections++))
  }
done

count=0
while true; do
  ((count++))
  ((count>junctions)) && {
    break
  }
  [ $parent[count] = "$count" ] && {
    final_tally+=${size[count]}
  }
done

final_tally=("${(@on)final_tally}")

print "Largest circuits: ${final_tally[1]} ${final_tally[2]} ${final_tally[3]}"

int result=$((final_tally[1]*final_tally[2]*final_tally[3]))

print $result
