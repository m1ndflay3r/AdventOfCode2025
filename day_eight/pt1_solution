#!/usr/bin/env zsh

## env setup

# load zsh/mathfunc module
zmodload zsh/mathfunc

# read input into variable, err if not found
dayeight_input=$(<input) || {
  print "Error: could not find \'input\'"
  return 1
}

# declare linear arrays for x y z
declare -a x y z

# declare associative array for distances
declare -A distances

# initialize junctions to 0
junctions=0

## helper functions


## parsing steps

# parse input by newline
IFS=$'\n'
for input_line in $=dayeight_input; do
  # increase junctions count
  ((junctions++))
  # ensure X Y and Z are blank
  X=''
  Y=''
  Z=''
  # set IFS to ',' to further parse each line
  IFS=$','
  for coord in $=input_line; do
    # if Z is blank, must be Y (first coord)
    [ -z "$Z" ] && {
      Z=$coord
    # elif Y is blank, must by Y (second coord)
    } || {
      [ -z "$Y" ] && {
        Y=$coord
      # else must be X (third coord)
      } || {
        X=$coord
      }
    }
  done
  unset IFS
  # add current $Z, $Y, and $X to their respective linear arrays at indice $junctions
  z[$junctions]="$Z"
  y[$junctions]="$Y"
  x[$junctions]="$X"
done
unset IFS

## main

count_a=0
# iterate over input by newline once more
IFS=$'\n'
for input_line in $=dayeight_input; do
  # increase count_a by 1, unset oldroot, set count_b to count_a
  ((count_a++))
  unset oldroot
  count_b=0
  while true; do
    # increase count_b by 1, and break if exceeds total junctions
    ((count_b++))
    # cant check distance against self - increase count by 1 again
    [ "$count_a" = "$count_b" ] && {
      ((count_b++))
    }
    ((count_b>junctions)) && {
      break
    }
    # extract z1, y1, x1, z2, y2, and x2 from linear arrays using count_a and count_b
    z1=$z[$count_a]; y1=$y[$count_a]; x1=$x[$count_a]
    z2=$z[$count_b]; y2=$y[$count_b]; x2=$x[$count_b]
    # calculate distance
    # x2-x1 squared
    x_res=$(((x2-x1)*(x2-x1)))
    # y2-y1 squared
    y_res=$(((y2-y1)*(y2-y1)))
    # z2-z1 squared
    z_res=$(((z2-z1)*(z2-z1)))
    # add results of above together into variable to_root
    to_root=$((x_res+y_res+z_res))
    # set root to square root of to_root
    ((root=sqrt(to_root)))
    # if oldroot not empty, this is not first loop
    ! [ -z "$oldroot" ] && {
      # if root is smaller than oldroot, it becomes new oldroot.
      ((root<oldroot)) && {
        oldroot="$root"
        # record count_b corresponding to current smallest
        closest="$count_b"
      }
    # else must be first loop, so oldroot and closest = current root and count_b
    } || {
      oldroot="$root"
      closest="$count_b"
    }
  done
  # reconstruct key of closest junction
  clos_key=""$z[$closest]","$y[$closest]","$x[$closest]""
  # save calculated distance + key of closest junction to distances, corresponding to current junction
  distances[$input_line]=""$oldroot" "$clos_key""
done
unset IFS

# print distances recorded
distance_keys=$distances[(I)*,*,*]
IFS=$' '
for key in ${(@on)=distance_keys}; do
  print $distances[$key]
done
unset IFS
