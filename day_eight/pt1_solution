#!/usr/bin/env zsh

## env setup

# load zsh/mathfunc
zmodload zsh/mathfunc

# read input, error if not found
dayeight_input=$(<input) || {
  print "Error: could not find \'input\'"
  return 1
}

declare -a x y z parent size all_edges
integer junctions=0

## parsing steps

print "Parsing input..."

IFS=$'\n'
for input_line in $=dayeight_input; do
  ((junctions++))
  local -a parts=( "${(@s:,:)input_line}" )
  x[$junctions]=${parts[1]}
  y[$junctions]=${parts[2]}
  z[$junctions]=${parts[3]}
done
unset IFS

print "Parsed "$junctions" junctions"

## pair calculation

print "Calculating distances..."

integer count_a=0
integer edge_idx=0

while ((count_a < junctions)); do
  ((count_a++))
  integer count_b=$count_a
  while ((count_b < junctions)); do
    ((count_b++))

    typeset -F x1=$x[$count_a] y1=$y[$count_a] z1=$z[$count_a]
    typeset -F x2=$x[$count_b] y2=$y[$count_b] z2=$z[$count_b]
    typeset -F dist

    ((dist = sqrt( (x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2 )))

    local entry=$(printf "%.4f:%d:%d" $dist $count_a $count_b)

    # Explicit Indexing
    ((edge_idx++))
    all_edges[$edge_idx]=$entry
  done
done

print "Generated $edge_idx pairs. Sorting..."

# force IFS to default to ensure sort doesn't merge lines
IFS=$' \t\n'
all_edges=( "${(@n)all_edges}" )

## main

print "Beginning circuit wiring phase..."

integer i
for ((i=1; i<=junctions; i++)); do
  parent[i]=$i
  size[i]=1
done

integer max_connections=1000
((junctions < 50)) && {
  print "Small input detected. Limiting to 10 connections."
  max_connections=10
}
((max_connections > ${#all_edges})) && max_connections=${#all_edges}

# C-style iteration
for ((k=1; k<=max_connections; k++)); do

  # fetch edge by explicit index
  local edge=${all_edges[k]}

  # extract V (everything after last colon)
  integer v=${edge##*:}

  # trim V from string
  local temp=${edge%:*}

  # extract U (everything after new last colon)
  integer u=${temp##*:}

  # union-find logic
  integer root_u=$u
  while ((parent[root_u] != root_u)); do
    root_u=$parent[root_u]
  done
  integer curr=$u
  while ((curr != root_u)); do
    integer next=$parent[curr]
    parent[curr]=$root_u
    curr=$next
  done

  integer root_v=$v
  while ((parent[root_v] != root_v)); do
    root_v=$parent[root_v]
  done
  curr=$v
  while ((curr != root_v)); do
    integer next=$parent[curr]
    parent[curr]=$root_v
    curr=$next
  done

  ((root_u != root_v)) && {
    ((size[root_u] < size[root_v])) && {
      parent[root_u]=$root_v
      ((size[root_v] += size[root_u]))
    } || {
      parent[root_v]=$root_u
      ((size[root_u] += size[root_v]))
    }
  }
done

print "Wiring complete."

## results

declare -a final_tally
for ((i=1; i <= junctions; i++)); do
  ((parent[i] == i)) && {
    final_tally+=${size[i]}
  }
done

final_tally=( "${(@On)final_tally}" )

print "Largest circuits: ${final_tally[1]}, ${final_tally[2]}, ${final_tally[3]}"

integer val1=${final_tally[1]:-1}
integer val2=${final_tally[2]:-1}
integer val3=${final_tally[3]:-1}

integer result=$((val1 * val2 * val3))
print "Result: $result"
